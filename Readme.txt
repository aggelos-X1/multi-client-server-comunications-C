Problem 1: Multi-threaded network server (50 points).
Περιγραφή - Εκτέλεση.
Γράψτε έναν πολυνηματικό εξυπηρετητή δικτύου σε C/C++ που ονομάζεται poller το οποίο εκτελεί μια
προεκλογική δημοσκόπηση κομμάτων. Το πρόγραμμα θα το τρέχετε από τη γραμμή εντολής με τα
ακόλουθα ορίσματα
prompt> poller [portnum] [numWorkerthreads] [bufferSize] [poll-log][poll-stats]
Συγκεκριμένα τα ορίσματα είναι:
● portnum: ο αριθμός θύρας που ακούει ο εξυπηρετητής
● numWorkerthreads: ο αριθμός νημάτων εργατών που θα δημιουργήσει για να κάνει τη
δημοσκόπηση. Πρέπει να είναι > 0.
● bufferSize: το μέγεθος ενός buffer που θα κρατά συνδέσεις από πελάτες που περιμένουν να
εξυπηρετηθούν. Πρέπει να είναι > 0.
● poll-log: το όνομα ενός αρχείου όπου θα αποθηκεύονται τα ονόματα χρηστών και οι ψήφοι
τους.
● poll-stats: το όνομα ενός αρχείου όπου θα αποθηκεύονται τα αποτελέσματα (π.χ., ο αριθμός
χρηστών που έχουν ψηφίσει καθε κόμμα).
Τα ορίσματα είναι όλα υποχρεωτικά και πρέπει να δίνονται με τη συγκεκριμένη σειρά και μόνο.
Για παράδειγμα, αν τρέξετε το πρόγραμμα σας με τα ακόλουθα ορίσματα:
prompt> poller 5634 8 16 pollLog.txt pollStats.txt
τότε ο εξυπηρετητής θα ακούει στη θύρα 5634, θα δημιουργήσει 8 νήματα εργάτες, θα χρησιμοποιήσει
ένα buffer που κρατά μέχρι 16 συνδέσεις που περιμένουν εξυπηρέτηση, και θα αποθηκεύει τις ψήψους
των χρηστών στο pollLog.txt και τα αποτελέσματα της δημοσκόπησης στο αρχείο pollStats.txt.
Υλοποίηση
Ο εξυπηρετητής που θα υλοποιήσετε θα υποστηρίζει
● τη δημιουργία ενός νήματος-αρχηγού
● τη δημιουργία του buffer για την αποθήκευση των συνδέσεων
● την ενημέρωση του log αρχείου με τα στατιστικά της δημοσκόπησης
Master thread
Στην υλοποίηση σας, θα πρέπει να έχετε ένα νήμα-αρχηγό (master thread) που ξεκινά δημιουργώντας
numWorkerThread νήματα-εργάτες. Το master thread θα δέχεται συνδέσεις από πελάτες με την
accept κλήση συστήματος και θα τοποθετεί τους περιγραφείς αρχείων που αντιστοιχούν στις
συνδέσεις σε έναν buffer συγκεκριμένου μεγέθους (που ορίζεται από το bufferSize). Το νήμα-αρχηγός
ΔΕΝ θα διαβάζει από τις συνδέσεις που δέχεται. Απλώς, όποτε δέχεται κάποια σύνδεση θα τοποθετεί
τον socket descriptor στον buffer και θα συνεχίζει να δέχεται επόμενες συνδέσεις.
Workers threads
Η δουλειά των νημάτων-εργατών είναι να διαβάζουν τις αιτήσεις από τα socket descriptors και να
εξυπηρετούν τους πελάτες. Ένα νήμα-εργάτης ξυπνά όταν υπάρχει τουλάχιστον ένας descriptor στον
buffer (δηλαδή τουλάχιστον ένας πελάτης έχει συνδεθεί στον εξυπηρετητή).
Όταν ξυπνά, το νήμα-εργάτης, στέλνει το μήνυμα “SEND NAME PLEASE” και περιμένει να διαβάσει
από τον socket descriptor την απόκριση (το όνομα ενός ψηφοφόρου) από τον πελάτη.
Αν ο ψηφοφόρος έχει ήδη ψηφίσει, στέλνει απόκριση “ALREADY VOTED” και τερματίζει τη σύνδεση.
Αλλιώς στέλνει το μήνυμα “SEND VOTE PLEASE” και περιμένει να διαβάσει την απόκριση (μια
συμβολοσειρά με το όνομα ενός κόμματος).
Θα τυπώνει σε μια γραμμή, στο τέλος του poll-log αρχείου, το όνομα του ψηφοφόρου και το κόμμα που
ψήφισε. Τέλος στέλνει ένα μήνυμα “VOTE for Party XYZ RECORDED” (όπου το XYZ είναι το κόμμα
που ψήφισε ο ψηφοφόρος) και τερματίζει τη σύνδεση.
Συγχρονισμός Master-workers μέσω του buffer.
Το νήμα-αρχηγός και τα νήματα-εργάτες έχουν σχέση παραγωγού-καταναλωτή και έτσι στην υλοποίηση
σας θα πρέπει οι προσβάσεις τους στο κοινό buffer να συγχρονίζονται.
Συγκεκριμένα:
● το νήμα-αρχηγός πρέπει να μπλοκάρεται και να περιμένει όταν ο buffer είναι γεμάτος
● ένα νήμα-εργάτης πρέπει να περιμένει αν ο buffer είναι άδειος.
Με αυτή τη προσέγγιση, αν υπάρχουν περισσότερα νήματα-εργάτες από ενεργές συνδέσεις, τότε
κάποια από τα νήματα-εργάτες θα μπλοκάρονται, περιμένοντας νέες συνδέσεις να φτάσουν στον
εξυπηρετητή.
Σε αυτήν την εργασία, θα πρέπει να χρησιμοποιήσετε μεταβλητές συνθήκης στην υλοποίηση σας. Αν
η υλοποίηση σας κάνει οτιδήποτε busy-waiting, θα υπάρξει ποινή (-20 μονάδες).
Εξυπηρετητής- Αποθήκευση Στατιστικών
Ο εξυπηρετητής θα πρέπει να κρατήσει κάποια στοιχεία για την δημοσκόπηση:
● τα ονόματα χρηστών που έχουν συμμετάσχει μέχρι στιγμής στη δημοσκόπηση μαζί με τις
ψήφους τους, και
● τον αριθμό των χρηστών που έχουν ψηφίσει καθε κόμμα.
Στην υλοποίηση, θα πρέπει να αποθηκεύονται οι ψήφοι που λαμβάνει ο εξυπηρετητής στα αρχεία
poll-log και poll-stats καθώς στέλνονται. Προσοχή εάν πάρει σήμα τερματισμού ο εξυπηρετητής θα
πρέπει να γράψει τις ψήφους που έχει πάρει ως εκείνη τη στιγμή πριν τερματίσει ώστε το αποτέλεσμα
να είναι σωστό. Μπορείτε να κρατήσετε αυτά τα στοιχεία σε οποιαδήποτε δομή δεδομένων σας
εξυπηρετεί.
Καθώς τα νήματα που εξυπηρετούν τους χρήστες θα πρέπει να ενημερώνουν τα δεδομένα που κρατά
ο server, θα πρέπει να υλοποιήσετε και τον κατάλληλο συγχρονισμό ώστε να γίνονται
τροποποιήσεις στα δεδομένα με σωστό τρόπο.
Ασχέτως τον τρόπο που θα επιλεγεί για την ενημέρωση του αρχείου, η τελική τους μορφή θα έχει ώς
εξής
αρχείο poll-log:
voter_name1 party_voted_for1
voter_name2 party_voted_for2
.
.
.
O εξυπηρετητής θα τρέχει μέχρι να λάβει ένα SIGINT (control-C) σήμα. Όταν λάβει SIGINT, θα γράφει
τα αποτελέσματα της δημοσκόπησης στο αρχείο poll-stats με την ακόλουθη μορφή:
αρχείο poll-stats
party_name1 number_of_votes
party_name2 number_of_votes
party_name3 number_of_votes
.
.
.
TOTAL total_number_of_votes
Problem 2: Batch client for testing purposes (30 points) Γράψτε έναν πολυνηματικό πελάτη σε
C/C++ που ονομάζεται pollSwayer που παίρνει τρία ορίσματα:
prompt> pollSwayer [serverName] [portNum] [inputFile.txt]
όπου:
● serverName: το όνομα του εξυπηρετητή στον οποίο θα συνδεθεί
● portNum: αριθμός θύρας που ακούει ο εξυπηρετητής
● inputFile.txt: ένα αρχείο που περιέχει ονόματα και ψήφους των ψηφοφόρων
Τα ορίσματα είναι όλα υποχρεωτικά και πρέπει να δίνονται με τη συγκεκριμένη σειρά και μόνο.
Για παράδειγμα, αν τρέξετε το πρόγραμμα σας με τα ακόλουθα ορίσματα:
prompt> pollSwayer linux01.di.uoa.gr 5634 inputFile.txt
Το pollSwayer θα διαβάζει το inputFile.txt και για κάθε γραμμή με όνομα, επώνυμο, και ψήφο, θα
δημιουργεί ένα νήμα που θα συνδέεται στον εξυπηρετητή linux01.di.uoa.gr στο port 534 και θα του
στέλνει τη ψήφο ακολουθώντας το πρωτόκολλο που περιγράψαμε παραπάνω. Αν τρέξετε το
πρόγραμμα αυτό από πολλαπλά διαφορετικά κελύφη συγχρόνως θα σας βοηθήσει να βρείτε και να
διορθώσετε λάθη συγχρονισμού στον εξυπηρετητή σας.